
## 1. Вычислительные средства и архитектура

### Вычислительные средства компьютера

Это комплекс аппаратных («железо») и программных средств, выполняющих вычисления. Основа архитектуры (обычно фон Неймана или Гарвардская):

* **CPU (Процессор)**: «Мозг», исполняет инструкции.
* **Memory (Память)**: Хранит данные и программы.
* **Bus (Шина)**: Магистраль для передачи данных между блоками.

### Устройство микропроцессоров

Современный CPU — это кристалл кремния с миллиардами транзисторов.

* **Control Unit (УУ)**: Декодирует инструкции и управляет потоками данных.
* **Clock (Тактовый генератор)**: Задает ритм работы (ГГц).
* **Кэш (L1/L2/L3)**: Сверхбыстрая память на кристалле для минимизации простоев при обращении к ОЗУ.

### Регистры, АЛУ, прочие блоки

* **Регистры**: Самая быстрая память (доступ за 0-1 такт).
* *GPR (General Purpose)*: `RAX`, `RBX` (хранят данные).
* *Special*: `RIP` (Instruction Pointer — адрес следующей команды), `RSP` (Stack Pointer).


* **АЛУ (ALU)**: "Калькулятор" процессора. Выполняет битовые сдвиги, сложение, логическое И/ИЛИ.
* **FPU (Floating Point Unit)**: Блок для работы с дробными числами (float/double).

### Устройство оперативной памяти

ОЗУ (RAM) — это **энергозависимая** память с произвольным доступом.

* Физически это матрица ячеек (конденсатор + транзистор).
* Данные хранятся, пока подается питание (регенерация заряда).
* ОС видит память как линейный массив байтов с адресами.

---

## 2. Операционные системы (ОС)

### Основные функции ОС

ОС — это менеджер ресурсов компьютера.

1. **Абстракция**: Скрывает сложность железа за простым API (файлы, сокеты).
2. **Управление ресурсами**: Распределяет процессорное время (шедулинг) и память.
3. **Безопасность**: Разграничение прав доступа пользователей и процессов.

### Виды операционных систем

* **Пакетные (Batch)**: Ранние системы, задачи выполняются одна за другой (Mainframes).
* **Разделения времени (Time-sharing)**: Создают иллюзию одновременной работы для пользователя (Unix, Windows).
* **Реального времени (RTOS)**: Гарантируют реакцию за строго заданное время (QNX, VxWorks) — для роботов, медицины.

---

## 3. Системное программное обеспечение

### Определение

ПО, которое управляет компонентами компьютерной системы и служит платформой для запуска прикладных программ (браузеров, игр).

### Типы, примеры и особенности

1. **Базовая система ввода-вывода (BIOS/UEFI)**: Инициализация железа при старте.
2. **Загрузчики (Bootloaders)**: GRUB, Windows Boot Manager. Передают управление ядру ОС.
3. **Драйверы устройств**: Трансляторы команд ОС в электрические сигналы устройства (`nvidia.ko`).
4. **Системные утилиты**: Компиляторы, линковщики, отладчики (`gdb`), командные оболочки.

---

## 4. Структура ОС и Ядро

### Структура операционной системы

Обычно это слоеный пирог:
`Hardware` -> `Kernel` -> `System Call Interface` -> `User Space Libraries` -> `Applications`.

### Ядро (Kernel)

Центральная часть ОС. Загружается первой и остается в памяти. Работает в **привилегированном режиме** (Kernel Mode/Ring 0), имея полный доступ к аппаратуре.

### Виды ядер

1. **Монолитное (Linux, DOS)**: Драйверы, файловая система и управление памятью — единый бинарный файл. *Плюс: скорость. Минус: сбой драйвера может обвалить всю систему.*
2. **Микроядро (Minix, QNX)**: В ядре только планировщик и IPC. Драйверы работают как обычные процессы. *Плюс: надежность. Минус: накладные расходы на обмен сообщениями.*
3. **Гибридное (Windows NT, macOS)**: Компромисс. Основные драйверы в ядре, но архитектура модульная.

---

## 5. Системные вызовы (Syscalls)

### Назначение и типы

Это единственный легальный способ для программы попросить что-то у ядра (например, прочитать файл). Программа не может сама лезть в диск или память другого процесса.

* *Типы*: `fork` (процессы), `read/write` (IO), `socket` (сеть), `chmod` (права).

### Интерфейс ядра Linux

Приложение вызывает функцию из `glibc` (например, `open()`). Библиотека кладет номер системного вызова в регистр `RAX` и вызывает прерывание (инструкция `syscall` или `int 0x80`). Процессор переключается в режим ядра, выполняет действие и возвращает результат.

---

## 6. Процессы

### Определение и жизненный цикл

**Процесс** — экземпляр запущенной программы + её ресурсы (память, дескрипторы файлов).

* **Жизненный цикл**:
1. *New*: Создание.
2. *Ready*: Готов к работе, ждет CPU.
3. *Running*: Исполняется на CPU.
4. *Waiting/Blocked*: Ждет ввода-вывода.
5. *Terminated*: Завершен.



### Обособленность

Каждый процесс имеет свое **виртуальное адресное пространство**. Один процесс не может случайно записать данные в память другого (Segmentation Fault).

### Процессы в Linux: fork() и wait()

В Linux новые процессы создаются клонированием.

```c
pid_t pid = fork(); // Раздвоение процесса
if (pid == 0) {
    // Это код дочернего процесса (Child)
    exec(...); // Замена кода на новую программу
} else {
    // Это код родителя (Parent)
    wait(NULL); // Ждем, пока ребенок завершится
}

```

* `fork()` возвращает `0` ребенку и `PID ребенка` родителю.

---

## 7. Потоки (Threads)

### Определение и назначение

Поток — единица планирования внутри процесса.

* **Разница**: Процессы изолированы, потоки делят **общую память** (кучу, глобальные переменные) одного процесса.
* **Назначение**: Параллелизм (использование всех ядер CPU), отзывчивость интерфейса.

### Проблемы многопоточности

Главная проблема — **синхронизация**. Если два потока одновременно пишут в одну переменную, результат непредсказуем (Race Condition). Используются мьютексы, семафоры, атомики.

### Реализация в Pthreads

Стандарт POSIX Threads (`#include <pthread.h>`).

* `pthread_create`: Запуск функции в новом потоке.
* `pthread_join`: Аналог `wait` для потоков (ожидание завершения).
* `pthread_mutex_lock/unlock`: Блокировка критической секции.

---

## 8. IPC: Сигналы и Сокеты

**IPC (Inter-Process Communication)** — механизмы обмена данными между процессами.

### Сигналы (Signals)

Программные прерывания. Самый примитивный способ IPC. Не передают данных, только номер события.

* `SIGINT` (Ctrl+C): Прерывание.
* `SIGKILL`: Безусловное убийство процесса.
* `SIGSEGV`: Ошибка памяти.
Приложение может перехватывать сигналы (кроме SIGKILL) через `signal()` или `sigaction()`.

### Сокеты (Sockets)

Универсальный интерфейс. Позволяют общаться процессам как на одном ПК (Unix Domain Sockets), так и через интернет (TCP/UDP). Работают по принципу "Клиент-Сервер".

---

## 9. IPC: Pipe и Общая память

### Pipe (Каналы)

* **Неименованные (`|`)**: Работают только между родственными процессами (родитель-ребенок). Однонаправленные. Данные идут как поток байтов.
* **Именованные (FIFO)**: Файл специального типа в системе. Любые процессы могут писать/читать в него.

### Shared Memory (Общая память)

Самый быстрый метод IPC.
ОС мапит (отображает) одни и те же физические страницы памяти в адресные пространства разных процессов.

* *Плюс*: Нет копирования данных (Zero-copy).
* *Минус*: Нужна сложная синхронизация (семафоры), чтобы не испортить данные.

---

## 10. Менеджмент памяти

### Виртуализация памяти

Технология, позволяющая процессу думать, что у него есть непрерывная память от `0` до `Max`.
**MMU (Memory Management Unit)** — аппаратный блок процессора, который на лету транслирует *Виртуальный адрес* в *Физический*.

### Страницы и сегменты

* **Страницы (Paging)**: Память делится на блоки фиксированного размера (4 KiB). Позволяет эффективно использовать ОЗУ и реализовывать свопинг (выгрузку неиспользуемых страниц на диск).
* **Сегменты**: Логическое деление (код, стек, данные). В современных x86-64 системах используется "Плоская модель" (Flat memory model), где сегментация сведена к минимуму, а основную роль играет страничная организация.

---

## 11. Адресное пространство процесса в Linux

### Адресное пространство процесса

Это диапазон виртуальных адресов, доступных процессу. В 32-битных системах это обычно 4 ГБ (где 1 ГБ отведен под ядро, 3 ГБ — под пользователя), в 64-битных — гораздо больше. Пространство виртуальное: физические страницы памяти подгружаются по требованию (Demand Paging).

### Сегменты памяти (Структура)

1. **Стек (Stack)**: Растет "вниз" (от старших адресов к младшим). Хранит локальные переменные, адреса возврата функций и аргументы. Управляется автоматически.
2. **Куча (Heap)**: Растет "вверх". Область динамической памяти, управляемая программистом (функции `malloc`/`free`, оператор `new`).
3. **Data (BSS и Data)**:
* **Data**: Инициализированные глобальные и статические переменные (например, `int x = 10;`).
* **BSS**: Неинициализированные переменные (например, `int y;`), которые зануляются ядром перед стартом.


4. **Text (Code)**: Содержит машинные инструкции программы. Обычно доступен только для чтения (Read-Only), чтобы избежать случайной модификации кода.

---

## 12. Накопители и подсистема ввода-вывода

### Строение жестких дисков и накопителей

* **HDD (Hard Disk Drive)**: Механическое устройство. Данные хранятся на намагниченных пластинах. Адресация происходит по цилиндрам, головкам и секторам (CHS) или логическим блокам (LBA).
* **SSD (Solid State Drive)**: Использует флеш-память (NAND). Нет движущихся частей, доступ к данным почти мгновенный, но ресурс записи ячеек ограничен.

### Работа подсистемы ввода-вывода

ОС работает с дисками через **драйверы блочных устройств**. Основная задача ОС — кэширование данных (Page Cache) и планирование запросов (I/O Scheduler), чтобы минимизировать перемещение головок диска (для HDD) и оптимизировать очередь команд.

### Логические диски и RAID-массивы

* **Логические разделы (Partitioning)**: Разбиение физического диска на части (MBR или GPT).
* **LVM (Logical Volume Manager)**: Позволяет гибко менять размеры разделов "на лету", объединяя несколько дисков в одну логическую группу.
* **RAID (Redundant Array of Independent Disks)**:
* **RAID 0 (Stripe)**: Ускорение (данные пишутся блоками на разные диски). Отказ одного диска убивает весь массив.
* **RAID 1 (Mirror)**: Надежность (полная копия данных на втором диске).
* **RAID 5**: Баланс (данные + контрольные суммы распределены по дискам). Переживает отказ 1 диска.



---

## 13. Файловая система (ФС)

### Строение файловой системы

ФС определяет способ хранения и именования данных. В Linux основой является **inode (индексный дескриптор)** — структура, хранящая метаданные файла (права, владелец, размер, ссылки на блоки данных), но не имя файла. Имя хранится в каталоге.

### Типы файлов

1. **Обычные файлы (`-`)**: Текст, картинки, бинарники.
2. **Каталоги (`d`)**: Списки имен файлов и их inode.
3. **Специальные файлы устройств (`c`, `b`)**: Символьные (клавиатура) и блочные (диск).
4. **Именованные каналы (`p`)**, **Сокеты (`s`)**, **Символические ссылки (`l`)**.

### Виртуальная файловая система (VFS)

Это абстрактный слой ядра. Программы используют стандартные вызовы (`open`, `read`, `write`), а VFS перенаправляет их конкретному драйверу (ext4, NTFS, NFS), скрывая детали реализации.

### Монтирование

Процесс присоединения файловой системы (с флешки, диска или сети) к определенной точке в дереве каталогов (например, `/mnt/usb`).
`mount /dev/sdb1 /mnt/data` — подключить раздел.

---

## 14. Интерфейс операционной системы

### Виды интерфейсов

1. **CLI (Command Line Interface)**: Основной способ управления серверами. Высокая скорость работы, возможность автоматизации (скрипты), низкое потребление ресурсов.
2. **GUI (Graphical User Interface)**: В Linux реализуется через X Window System (X11) или Wayland + Desktop Environment (GNOME, KDE). Удобен для мультимедиа и офисной работы.
3. **API (Application Programming Interface)**: Интерфейс для программистов (системные вызовы, библиотеки).

---

## 15. Операционная система Linux

### История и особенности

Ядро разработано Линусом Торвальдсом в 1991 году.

* **Монолитное ядро с модулями**: Драйверы можно подгружать на лету (`modprobe`), не пересобирая ядро.
* **POSIX-совместимость**: Следование стандартам Unix.
* **Многопользовательность и вытесняющая многозадачность**.

### Дистрибутивы Linux

Linux — это ядро. Дистрибутив — это Ядро + GNU утилиты + Пакетный менеджер + Графическая оболочка.

* **Debian-based**: Ubuntu, Linux Mint (используют `apt` и `.deb`).
* **RedHat-based**: CentOS, Fedora, RHEL (используют `dnf`/`yum` и `.rpm`).
* **Arch-based**: Arch Linux, Manjaro (модель Rolling Release, всегда свежий софт).

---

## 16. Системные и прикладные программы в Linux

### Категории ПО

* **Текстовые редакторы**:
* `Vim`, `Nano`: Консольные, работают везде.
* `VS Code`, `Sublime`: Графические.


* **Программы-фильтры (Pipeline friendly)**: Утилиты, читающие со стандартного ввода и пишущие на вывод.
* `grep`: Поиск строк по шаблону.
* `sed`: Потоковый редактор текста.
* `awk`: Язык обработки структурированного текста.


* **Интерпретаторы командной строки (Shell)**:
* `Bash`: Стандарт де-факто.
* `Zsh`: Расширенная версия с плагинами.
* `Sh`: Базовая оболочка (стандарт POSIX).



---

## 17. Компиляция программ (GCC)

### Этапы компиляции на примере GCC

Команда `gcc main.c` проходит 4 стадии:

1. **Препроцессинг (`cpp`)**: Раскрытие `#include`, макросов `#define`, удаление комментариев.
* *Флаг: `gcc -E*`


2. **Компиляция (`cc1`)**: Трансляция кода C в код Ассемблера.
* *Флаг: `gcc -S` (создает `.s` файл).*


3. **Ассемблирование (`as`)**: Перевод ассемблера в машинный код (объектный файл).
* *Флаг: `gcc -c` (создает `.o` файл).*


4. **Линковка (Компоновка) (`ld`)**: Объединение объектного файла с библиотеками (например, `printf` из `libc`) в готовый исполняемый файл.

---

## 18. Структура каталогов в Linux (FHS)

Стандарт иерархии файловой системы (Filesystem Hierarchy Standard):

* `/` (Root): Корень всей системы.
* `/bin` и `/sbin`: Основные утилиты (ls, cp) и системные утилиты (ip, fdisk).
* `/etc`: Конфигурационные файлы (настройки системы).
* `/home`: Домашние каталоги пользователей.
* `/var`: Изменяемые данные (логи, кэши, базы данных).
* `/proc` и `/sys`: Виртуальные ФС, отображающие состояние ядра и железа в виде файлов.
* `/dev`: Файлы устройств (например, `/dev/sda`).

---

## 19. Права доступа к файлам в Linux

### Базовые права (rwx)

Хранятся в inode. Делятся на три группы: **User** (владелец), **Group** (группа владельца), **Others** (все остальные).

* `r` (4) — чтение (просмотр файла или содержимого папки).
* `w` (2) — запись (изменение файла или создание/удаление файлов в папке).
* `x` (1) — исполнение (запуск программы или вход в папку).
*Пример:* `chmod 755 file` (rwx для владельца, r-x для остальных).

### Расширенные права

1. **Специальные биты**:
* **SUID**: Запуск файла с правами его *владельца* (например, `passwd`).
* **SGID**: Запуск с правами *группы* (или наследование группы в папке).
* **Sticky Bit**: Запрет на удаление чужих файлов в общей папке (используется в `/tmp`).


2. **ACL (Access Control Lists)**: Позволяют дать права конкретному пользователю, не меняя владельца группы (команды `getfacl`, `setfacl`).
