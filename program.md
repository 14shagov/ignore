
### Program 01: Создание процесса (fork)

Эта программа демонстрирует создание нового процесса с помощью системного вызова `fork()`.

**Разбор кода:**

* `#include ...`: Подключение библиотек для ввода-вывода и системных типов.
* `pid_t pid = fork();`:
* **Действие:** Функция `fork()` "раздваивает" текущий процесс. Она создает точную копию текущего процесса (дочерний процесс).
* **Переменная `pid` (Process ID):** `fork()` возвращает значение типа `pid_t` (целое число).
* Родителю возвращается ID ребенка (число > 0).
* Ребенку возвращается `0`.




* `if (pid == 0) { ... }`: Эта часть выполняется **только** внутри дочернего процесса.
* `getpid()`: Системный вызов, возвращающий ID текущего процесса.


* `else if (pid > 0) { ... }`: Эта часть выполняется **только** внутри родительского процесса. 


Здесь программа печатает PID своего ребенка, который хранится в переменной `pid`.



**Почему так названы переменные:**

* **`pid`**: Сокращение от **P**rocess **ID**entifier (идентификатор процесса).
* **`pid_t`**: Тип данных (_t означает type), специально предназначенный для хранения ID процессов.

---

### Program 02: Запуск другой программы (exec)

Программа заменяет себя системной утилитой `ls` (список файлов). 

**Разбор кода:**

* `char *args[] = {"/bin/ls", "-l", NULL};`:
* Создается массив строк (аргументов).
* `"/bin/ls"`: Полный путь к программе, которую хотим запустить.
* `"-l"`: Флаг для детального вывода списка файлов.
* `NULL`: Обязательный маркер конца массива аргументов.


* `execv(args[0], args);`:
* **Действие:** Заменяет текущий процесс программой, указанной в первом аргументе. Если функция сработала успешно, код после этой строки **никогда** не выполнится (так как старой программы больше нет).


* `perror("exec failed");`: Выполняется только если `execv` вернула ошибку. `perror` печатает понятное сообщение об ошибке.

**Почему так названы переменные:**

* **`args`**: Сокращение от **arg**ument**s** (аргументы командной строки).

---

### Program 03: Обмен данными (Pipe)

Демонстрация передачи данных от родителя к ребенку через "трубу" (pipe). 

**Разбор кода:**

* `int fd[2];`: Массив из двух целых чисел.
* `pipe(fd);`: Создает однонаправленный канал данных.
* `fd[0]`: Конец для **чтения** (Read).
* `fd[1]`: Конец для **записи** (Write).


* `fork()`: Создает копию процесса. Оба процесса теперь имеют доступ к открытым дескрипторам трубы.
* **Внутри ребенка (`if`):**
* `write(fd[1], msg, strlen(msg)+1);`: Пишет строку "Hello" в канал записи. `+1` нужно, чтобы записать и нулевой символ конца строки. 




* **Внутри родителя (`else`):**
* `char buf[32];`: Буфер (место) для хранения входящих данных.
* `read(fd[0], buf, sizeof(buf));`: Читает данные из канала чтения в буфер `buf`.
* `printf`: Выводит полученное сообщение.



**Почему так названы переменные:**

* **`fd`**: Сокращение от **F**ile **D**escriptor (файловый дескриптор). В Linux все (файлы, трубы, сокеты) управляется через эти числовые идентификаторы.
* **`buf`**: Сокращение от **buf**fer (буфер, временное хранилище памяти).

---

### Program 04: Запись в файл

Создание файла и запись в него текста. 

**Разбор кода:**

* `int fd = open("test.txt", O_CREAT | O_WRONLY, 0644);`:
* `open`: Системный вызов для открытия файла.
* `O_CREAT`: Создать файл, если его нет.
* `O_WRONLY`: Открыть только для записи (**Wr**ite **Only**).
* `0644`: Права доступа к файлу (владелец может читать/писать, остальные — только читать).


* `write(fd, "Hello, file!\n", 14);`: Записывает 14 байт данных в файл, на который указывает дескриптор `fd`.
* `close(fd);`: Освобождает дескриптор. Хорошая практика — всегда закрывать файлы.

**Почему так названы переменные:**

* **`fd`**: См. выше (File Descriptor). Если `open` возвращает -1, значит произошла ошибка.

---

### Program 05: Динамическая память

Работа с выделением памяти в куче (heap). 

**Разбор кода:**

* `int *arr = malloc(5 * sizeof(int));`:
* `malloc`: Выделяет блок памяти указанного размера.
* `sizeof(int)`: Размер одного целого числа (обычно 4 байта). Мы просим память под 5 чисел.


* 
`arr[i] = i * i;`: Заполняет массив квадратами индексов (0, 1, 4, 9, 16). 


* 
`printf...`: Выводит массив на экран. 


* `free(arr);`: **Критически важно.** Освобождает память. Если этого не сделать, произойдет "утечка памяти".

**Почему так названы переменные:**

* **`arr`**: Сокращение от **arr**ay (массив).
* **`i`**: Традиционное имя для **i**ndex (индекса) или **i**terator (итератора) в циклах.

---

### Program 06: Обработка сигналов

Программа перехватывает сигнал прерывания (обычно Ctrl+C). 

**Разбор кода:**

* `void handler(int sig) { ... }`: Функция-обработчик. Она будет вызвана автоматически, когда придет сигнал.
* `_exit(0)`: Безопасный выход из программы внутри обработчика сигнала.


* `signal(SIGINT, handler);`:
* Говорит системе: "Если придет сигнал `SIGINT` (Interruption), не убивай программу сразу, а выполни функцию `handler`".


* `while(1) sleep(1);`: Бесконечный цикл, программа "спит" и ждет сигнала.

**Почему так названы переменные:**

* **`handler`**: Обработчик (тот, кто управляет событием).
* **`sig`**: Сокращение от **sig**nal (номер сигнала).

---

### Program 07: Синхронизация (Wait)

Родитель ждет, пока ребенок закончит работу. 

**Разбор кода:**

* 
`if (pid == 0)`: Ребенок спит 1 секунду, печатает сообщение и завершается. 


* `else { wait(NULL); ... }`:
* `wait(NULL)`: Этот системный вызов блокирует родительский процесс. Родитель "зависает" на этой строчке до тех пор, пока **любой** из его детей не завершится.
* Это предотвращает появление "зомби-процессов" (процессов, которые завершились, но их родитель не считал их код возврата).



---

### Program 08: Чтение из файла

Открывает существующий файл и читает его содержимое. 

**Разбор кода:**

* `open("test.txt", O_RDONLY);`: Открывает файл только для чтения (**R**ea**d** **Only**).
* `if (fd == -1) return 1;`: Проверка на ошибку (например, файла не существует).
  
`char buf[128];`: Буфер для чтения. 


* `int n = read(fd, buf, sizeof(buf)-1);`:
* Пытается прочитать данные в буфер.
* `n`: Возвращает количество реально прочитанных байт.
* `sizeof(buf)-1`: Мы оставляем 1 байт запаса для символа конца строки.


* `buf[n] = '\0';`: В C строки должны заканчиваться "нулевым символом". `read` его не ставит автоматически, мы делаем это вручную, чтобы `printf` не вывел мусор из памяти.

**Почему так названы переменные:**

* **`n`**: Часто используется для обозначения **n**umber (количества) байт или элементов.

---

### Program 09: Копирование файла

Копирует содержимое `source.txt` в `copy.txt`. 

**Разбор кода:**

* `src`: Дескриптор исходного файла (открыт на чтение).
* `dst`: Дескриптор файла назначения (открыт на запись + создание). Права `0644`.
  
`while ((n = read(src, buf, sizeof(buf))) > 0)`: 


* Это классический цикл копирования.
* `read` читает кусок файла в буфер и возвращает количество байт `n`.
* Если `n > 0`, значит мы что-то прочитали.
* Внутри цикла: `write(dst, buf, n);` — записываем ровно столько байт (`n`), сколько прочитали, в файл назначения.
* Цикл повторяется, пока `read` не вернет 0 (конец файла).


* `close(src); close(dst);`: Закрываем оба файла.

**Почему так названы переменные:**

* **`src`**: **S**ou**rc**e (источник).
* **`dst`**: **D**e**st**ination (назначение).
